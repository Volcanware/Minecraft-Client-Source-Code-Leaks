package me.aidanmees.trivia.client.modules.Exploits;

import org.lwjgl.input.Keyboard;

import me.aidanmees.trivia.client.WaitTimer;
import me.aidanmees.trivia.client.events.BoundingBoxEvent;
import me.aidanmees.trivia.client.module.state.Category;
import me.aidanmees.trivia.client.settings.ClientSettings;
import me.aidanmees.trivia.client.tools.LiquidUtils;
import me.aidanmees.trivia.client.tools.Timer1;
import me.aidanmees.trivia.gui.custom.clickgui.ModSetting;
import me.aidanmees.trivia.gui.custom.clickgui.SliderSetting;
import me.aidanmees.trivia.gui.custom.clickgui.ValueFormat;
import me.aidanmees.trivia.module.Module;
import net.minecraft.block.Block;
import net.minecraft.block.BlockAir;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.BlockPos;
import net.minecraft.util.MathHelper;
import net.minecraft.util.MovementInput;

public class Phase extends Module {

	boolean didSend = false;
	int times = 0;
	private int resetNext;

	  private boolean ncpSetup = false;
	WaitTimer timer = new WaitTimer();
	Timer1 timer2 = new Timer1();
     String mode2 = "NCP";
	
	
	@Override
	public ModSetting[] getModSettings() {
//		BasicSlider slider1 = new BasicSlider("Test Mode Distance", ClientSettings.Phasedistance, 0, 10, 0,
//				ValueDisplay.DECIMAL);
//		slider1.addSliderListener(new SliderListener() {
//
//			@Override
//			public void onSliderValueChanged(Slider slider) {
//				ClientSettings.Phasedistance = slider.getValue();
//			}
//		});
		SliderSetting<Number> slider1 = new SliderSetting<Number>("Test Distance", ClientSettings.Phasedistance, 0, 10, 0.0, ValueFormat.DECIMAL);
		return new ModSetting[] { slider1 };
	}

	public Phase() {
		super("Phase", Keyboard.KEY_NONE, Category.MOVEMENT,
				"You can go through shit like blocks! cul right?");
	}

	@Override
	public void onDisable() {
		times = 0;
		mc.thePlayer.noClip = false;
		didSend = false;
		super.onDisable();
	}
	@Override
	public void onEnable(){
	if (currentMode.equals("NCP")){
		if (mode2.equals("NCPDisable")) {
		      mode2 = "NCP";
		    }
		    if (mode2.equals("NCP"))
		    {
		      this.ncpSetup = false;
		      timer2.reset();
		    
		    }
	}
	}

	@Override
	public String[] getModes() {
		return new String[] { "New", "NCP" };
	}

	@Override
	public void onUpdate() {
		 if (isInsideBlock()) {
	          return;
	        }
	        double multiplier = 0.2D;
	        double mx = Math.cos(Math.toRadians(mc.thePlayer.rotationYaw + 90.0F));
	        double mz = Math.sin(Math.toRadians(mc.thePlayer.rotationYaw + 90.0F));
	      
	        
	        if (currentMode.equals("NCP")){
		
			  multiplier = 0.31D;
        }
		
        double x = mc.thePlayer.movementInput.moveForward * multiplier * mx + mc.thePlayer.movementInput.moveStrafe * multiplier * mz;
        double z = mc.thePlayer.movementInput.moveForward * multiplier * mz - mc.thePlayer.movementInput.moveStrafe * multiplier * mx;
        
          if ((mc.thePlayer.isCollidedHorizontally) && (!mc.thePlayer.isOnLadder()) && (!isInsideBlock()))
          {
            mc.thePlayer.sendQueue.addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX + x, mc.thePlayer.posY, mc.thePlayer.posZ + z, false));
            for (int i = 1; i < 11; i++) {
              mc.thePlayer.sendQueue.addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, Double.MAX_VALUE * i, mc.thePlayer.posZ, false));
            }
            double posX = mc.thePlayer.posX;
            double posY = mc.thePlayer.posY;
            mc.thePlayer.sendQueue.addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(posX, posY - (LiquidUtils.isOnLiquid() ? 9000.0D : 0.1D), mc.thePlayer.posZ, false));
            mc.thePlayer.setPosition(mc.thePlayer.posX + x, mc.thePlayer.posY, mc.thePlayer.posZ + z);
          
        }
		    if ((mode2.equals("NCPDisable")) && 
		      (mc.thePlayer.isCollidedHorizontally) && (!isInsideBlock()))
		    {
		      this.ncpSetup = false;
		      timer2.reset();
		      mode2 = "NCP";
		    }
		  
		
		if (currentMode.equals("New")){
			 this.resetNext -= 1;
			    double xOff = 0.0D;
			    double zOff = 0.0D;
			   
			    xOff = MovementInput.moveForward * 1.2D * mx + MovementInput.moveStrafe * 1.2D * mz;
			    zOff = MovementInput.moveForward * 1.2D * mz - MovementInput.moveStrafe * 1.2D * mx;
			    if (Phase.isInsideBlock()) {
			      this.resetNext = 1;
			    }
			    if (this.resetNext > 0) {
			      mc.thePlayer.boundingBox.offsetAndUpdate(xOff, 0.0D, zOff);
			    }
			  
		}
			
		super.onUpdate();
	}
	
	

	@Override
	public void onBoundingBox(BoundingBoxEvent event) {
	
		if (currentMode.equals("NCP")){
			if (mode2.equals("NCP") && (!this.ncpSetup) && 
				      (!this.ncpSetup) && (
				      ((isInsideBlock()) && (mc.gameSettings.keyBindJump.pressed)) || ((!isInsideBlock()) && (event.getBoundingBox() != null) && (event.getBoundingBox().maxY > mc.thePlayer.boundingBox.minY) && (mc.thePlayer.isSneaking())))) {
				      event.setBoundingBox(null);
				    
				  }
		}
		
		if (currentMode.equals("New")){
			
			    if (((Phase.isInsideBlock()) && (mc.gameSettings.keyBindJump.pressed)) || ((!Phase.isInsideBlock()) && (event.getBoundingBox() != null) && (event.getBoundingBox().maxY > mc.thePlayer.boundingBox.minY))) {
			      event.setBoundingBox(null);
			    }
			    
			  }
		
		
		
		super.onBoundingBox(event);
	}

	@Override
	public void onLateUpdate() {
		
		super.onLateUpdate();
	}

	

	public static boolean isInsideBlock() {
		for (int x = MathHelper.floor_double(mc.thePlayer.boundingBox.minX); x < MathHelper
				.floor_double(mc.thePlayer.boundingBox.maxX) + 1; x++) {
			for (int y = MathHelper.floor_double(mc.thePlayer.boundingBox.minY); y < MathHelper
					.floor_double(mc.thePlayer.boundingBox.maxY) + 1; y++) {
				for (int z = MathHelper.floor_double(mc.thePlayer.boundingBox.minZ); z < MathHelper
						.floor_double(mc.thePlayer.boundingBox.maxZ) + 1; z++) {
					Block block = mc.theWorld.getBlockState(new BlockPos(x, y, z)).getBlock();
					AxisAlignedBB boundingBox;
					if ((block != null) && (!(block instanceof BlockAir))
							&& ((boundingBox = block.getCollisionBoundingBox(mc.theWorld, new BlockPos(x, y, z),
									mc.theWorld.getBlockState(new BlockPos(x, y, z)))) != null)
							&& (mc.thePlayer.boundingBox.intersectsWith(boundingBox))) {
						return true;
					}
				}
			}
		}
		return false;
	}

}
